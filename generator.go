package main

//go:generate protoc -I./opts -I/usr/local/include --go_out=./opts --go_opt=paths=source_relative opts/opts.proto

import (
	"github.com/i9/protoc-gen-wrap/opts"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

// soltype to go type
var typeMap = map[string]string{
	"address": "ec.Address",
	"bytes32": "ec.Hash",
	"uint256": "*big.Int",
	"int256":  "*big.Int",
}

func mygen(p *protogen.Plugin) error {
	for _, f := range p.Files {
		if !f.Generate {
			continue
		}
		genOneFile(p, f)
	}
	return nil
}

type fieldSol struct {
	goName, solType string
}

func genOneFile(p *protogen.Plugin, f *protogen.File) {
	fname := f.GeneratedFilenamePrefix + "_wrap.go"
	g := p.NewGeneratedFile(fname, f.GoImportPath)
	g.P("// Code generated by protoc-gen-wrap. DO NOT EDIT.")
	g.P("package ", f.GoPackageName)
	g.P(Hdr)
	for _, msg := range f.Messages {
		insql, ok := proto.GetExtension(msg.Desc.Options(), opts.E_Insql).(bool)
		if ok {
			g.P("// ", insql)
		}
		var hasSol []*fieldSol
		for _, field := range msg.Fields {
			soltype, ok := proto.GetExtension(field.Desc.Options(), opts.E_Soltype).(string)
			if !ok {
				continue
			}
			hasSol = append(hasSol, &fieldSol{
				goName:  field.GoName,
				solType: soltype,
			})
		}
		if len(hasSol) == 0 {
			continue // or handle insql
		}
		g.P("type ", msg.GoIdent, "Wrap struct {")
		g.P("*", msg.GoIdent)
		for _, f := range hasSol {
			g.P(f.goName, "Wrap ", typeMap[f.solType])
		}
		g.P("}")
	}
}

const Hdr = `
import (
	"math/big"
	ec "github.com/ethereum/go-ethereum/common"
)
`
